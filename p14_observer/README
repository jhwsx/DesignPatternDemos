# 观察者模式

## 定义
定义了一种一对多的依赖关系，让多个观察者同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。
## 结构图
![](https://raw.githubusercontent.com/jhwsx/DesignPatternDemos/8294ef6bbb9fb5e864de254950600cf308a3104d/p14_observer/observer.png)

- Subject类，是主题或抽象通知者，管理着观察者，包括增删观察者对象，通知观察者更新；
- Observer类，是抽象观察者，定义一个更新接口；
- 具体Subject类；
- 具体Observer类。
## 优点
- 把观察者和被观察者之间的耦合关系由高度耦合变为抽象耦合；
- 建立了一套触发机制。
## 缺点
- 如果一个被观察者有很多的直接的和间接的观察者的话，将所有的观察者都通知到会花费很多时间；
- 如果在观察者和被观察者之间有依赖循环的话，被观察者会触发它们之间进行循环调用，可能导致系统崩溃；
- 观察者模式没有相应的机制让观察者知道被观察者是怎么发生变化的，而仅仅只是知道被观察者发生了变化；
- 尽管已经使用了依赖倒转原则，但是 ‘抽象通知者’ 还是依赖于 ‘抽象观察者’，也就是说万一没有了抽象观察者这样的接口，通知的功能就无法完成；
- 观察者模式的抽象观察者只提供了更新接口，而没有其它的方法。
## 使用场景
- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。这时使用观察者模式，可以将这些方面封装在独立的对象中，使它们可以各自独立地改变和复用。
- 一个对象的改变将导致其它一个或多个对象也发生改变，而不知道具体有多少对象要发生改变，应该使用观察者模式，可以降低对象之间的耦合度。
- 一个对象必须通知其它对象，而并不知道这些对象是谁时，应该使用观察者模式。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者创建一种链式触发机制。
## 注意事项
java.util包里，已经提供了一个Observable类和一个Observer接口，构成了java语言对观察者模式的支持。需要注意的地方是，在Observable类中的两个方法，setChanged（） 和 notifyObservers（） 。在调用后者之前，需要先调用一次前者，不然不会起作用的。

# 事件委托

## 定义
委托就像是拿另一种方法替换了原来的方法，交给这个替代后的方法使用，使用时和原来的方法没有区别。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。
## 优点
- 一个委托可以搭载多个方法，所有的方法将被依次唤起；
- 委托对象所搭载的方法并不需要属于同一个类，解决了抽象通知者与抽象观察者之间的耦合问题。
## 缺点
- 委托对象所搭载的所有方法必须具有相同的原形和形式，也就是拥有相同的参数类别和返回值类型。